abstract class Empl{
	private String empno;
	private String name;
	private int pay;

	abstract double getMontyPay(); //미완성 메서드
	
	Empl(String empno, String name, int pay){
		this.empno = empno;
		this.name = name;
		this.pay =pay;
	}
	void print() {
		System.out.println(empno);
		System.out.println(name);
		System.out.println(pay);
	}
	int getPay() {
		return pay;
	}

}//Empl
class FullTime extends Empl{
	int bonus;
	FullTime(String empno, String name, int pay, int bonus){
		super(empno,name,pay);
		this.bonus = bonus;
	}
	double getMontyPay() {
		int pay = getPay();
		return (pay/(double)12)+(bonus/(double)12);
	}
}//Fulltime
class Contract extends Empl{
	int hireYear;
	Contract(String empno, String name, int pay,int hireYear){
		super(empno,name,pay);
		this.hireYear = hireYear;
	}
	double getMontyPay() {
		return getPay()/(double)12*hireYear;
	}

}//Contract
class PartTime extends Empl{
	int workDay;
	PartTime(String empno, String name, int pay, int workDay){
		super(empno,name,pay);
		this.workDay = workDay;

	}
	double getMontyPay() {
		getPay();
		return getPay()*workDay;
		
	}
}//PartTime
public class Ex06_11_박이랑 {

	public static void main(String[] args) {
		Empl p = new PartTime("P01","제니",30,7); //계산된 급여
		System.out.println(p.getMontyPay());
		System.out.println();

		Empl c = new Contract("C02","웬디",200,3);//계산된 급여
		System.out.println(c.getMontyPay());
		System.out.println();

		Empl f = new FullTime("F03","윤아",400,200);//계산된 급여
		System.out.println(f.getMontyPay());
		System.out.println();

		p.print(); //"P01","제니",30
		c.print(); //"C02","웬디",200
		f.print(); //"F03","윤아",400

		System.out.println("==============");

		//객체배열로 똑같은 결과가 나오도록. 다형성의 목적!
		
		Empl[] arr = {new PartTime("P01","제니",30,7),
					new Contract("C02","웬디",200,3),
					new FullTime("F03","윤아",400,200)};
		int i;
		for(i=0;i<arr.length;i++) {
			arr[i].print();
		}
		
		for(i=0;i<arr.length;i++) {
			System.out.println(arr[i].getMontyPay());
		}
		
		

	}

}
